## 1.sql查询执行过程

项目中我们平时curd中主要是在于查，

__客户端-->连接器（连接管理，权限验证）-->分析器（如果查询缓存中存在直接返回结果）-->优化器-->执行器-->存储引擎__

从mysql基础架构上看：Mysql主要划分为__Server层和存储引擎层__

存储引擎:

myisam(不支持事务，只有表锁，注重性能)

innodb(支持事务,有行锁和表锁)

memory（内存）

## 2.sql更新过程

当mysql收到更新通知时，不会立即写到磁盘中，这样非常占IO，所有Innodb引擎会先把记录写到__redo log__里面，并更新内存，这个更新已经算完成了。存储引擎会在适当的时候，将这个记录更新到磁盘中（空闲时）;

而redo log大小时固定的，写到末尾从头开始写，所以它会有两个点记录write pos记录当前位置，checkpoint擦除的位置，保证数据能完整的写入磁盘中；

__bin log__ mysql server的日志模块，可以用于恢复数据

题：恢复mysql数据
生产上，有一张表数据量很大，这时候升级系统,如果A需要增加个字段，并发量白天都很大，请问怎么操作

因为数据量很大，修改表结构的时候会出现表锁，消耗时间很长，会导致这段时间卡顿；

首先创建一个和你要执行的alter操作的表一样的空间结构，然后copy原表的数据到新表；

在原表创建一个触发器在数据copy过程中，将原来更新的数据的操作全部更新到新的表中来；

copy完成后，用rename table表名，默认删除原表；

## 3.事务隔离级别
### 事务特性

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

### a.读未提交

顾名思义，一个事务还未提交，它的修改数据能被其他事务看到（脏读）
### b.读已提交

读取已提交的记录，但是又会不可重复读，意在同一个事务中，读两次，如果读第一次后，数据发生了改变，则会导致第二次读的数据与第一次读的数据不一致（不可重复读）

### c.可重复读

意在同一个事务a中，无论读多少次，结果都一样

### d.串行化读

如果执行一个修改在事务a中操作，比如set name=”serializable“，然后在未提交事务之前插入一个name=”summit“的时候，然后事务a提交，查询发现还存在name!="serializable"的数据，好比产生幻觉

## 4.索引

### 1）索引模型

哈希表 有序数组和搜索树

inNodb B+树索引

### 2）索引分类

主键索引（聚簇索引），非主键索引(二级索引)

区别：

id为主键索引，col为一般索引

主键索引，可以根据id =1，直接拿到行数据;

非主键索引，col=3，先找到id=1，然后拿到行数据,这就是__回表__

### 3) 避免回表,覆盖索引

覆盖索引 ：select返回的结果本身就是索引，无需回表

### 4) 最左前缀原则

### 5）索引下推

如果where条件的，col col2是联合索引，where col =1 and col2>6,

先优先判断col2的值是否为true，否则不回表

## 6.锁



### 1）全局锁

mysql自带全局加读锁方法（flush tables with read lock）简称FTWRL；

应用场景全库数据备份，

加上这个锁之后，如果你在主库备份，在这期间不能执行更新操作，也相当于当前业务操作基本停止，

如果在从库备份，主库在此期限更新操作，导致从库不能执行主库同步过来的binlog，会导致主从延迟

官方自带的逻辑备份工具mysqldump，当mysqldump使用-single-transaction，导数据之前启动一个事务，确保拿到一致性视图（myisam不支持，只适合所有表使用事务引擎的）

全库设置只读另一种方式，set global readonly =true（缺点：1. readonly参数常用判断一个库是主库还是从库 2. 如果在处理异常时，ftwrl执行异常，mysql会自动释放这个锁，回到之前状态，但是readonly会一直存在）

### 2）表级锁

表锁：

lock tables 	read/wirte;



元数据锁：metadata lock

读锁之间不会吃，读写 写写互斥，mdl锁系统默认添加

### 3）行锁

## 7.行锁

1.**两阶段锁**的概念是什么? 对事务使用有什么帮助?

在Innodb中，行锁是在需要的时候会加上，并不是不需要的时候立即释放，而是等到事务结束后才释放

帮助，如果事务中需要锁住多个行，要把最可能造成锁冲突的，最可能影响并发度的锁尽量往后放 ；

2.**死锁**的概念是什么? 举例说明出现死锁的情况.

不同资源出现循环依赖，涉及的线程在等待别的线程释放资源，会导致这几个线程出现无限等待状态,

场景:事务A出现更新一条然后事务b又更新一条 然后，事务a更新一条与B冲突，然后事务B更新一条与事务A第一条冲突时，就会发生死锁

3.**死锁的处理策略**有哪两种?

a.一直等待直到超时 

b.死锁检测（主动回滚其中一个事务，让其它事务得以继续执行）

4.等待超时处理死锁的机制什么?有什么局限?

等待时间的设置，太大 无法接受，太小，容易误伤，只是简单的业务逻辑上的等待，时间比较长而已

5.死锁检测处理死锁的机制是什么? 有什么局限?

如果新来一个线程都要判断自己是否被死锁，非常浪费cpu

6.有哪些思路可以解决热点更新导致的并发问题?

控制并发度

## 9.普通索引和唯一索引

查询几乎无差别

更新多的选择普通所用

## 10.mysql错选索引

mysql中的优化器中 选错索引，是由于索引统计信息不准确导致

我们可以使用force index(a)来强制指定索引

## 11.给字符串加索引

给字符串加索引时要注意最好使用**前缀索引**，（节省存储空间）长度最好控制在5-8

```

select 
count(distinct left(email,4)）as L4,
count(distinct left(email,5)）as L5,
count(distinct left(email,6)）as L6,
count(distinct left(email,7)）as L7,
from SUser;

```

统计前端索引的区分度，

注意 使用了前端索引，就无法使用覆盖索引

如果对省份证使用前端索引，前6位的区分度不高，

应该使用**倒序存储**

第二种则使用 **Hash字段**

均不支持范围查询，考虑实际情况

## 12.mysql会抖一下

**现象**：同一条sql，正常执行时，有时很快，有时却很慢

**原因**：Innodb处理更新语句时，只做了写日志操作，也就是更新内存写完redo log后，就返回客户端，本次更新就结束

mysql一般在空闲的时候会操作，或者redo 写满了，要flush脏页，又或者是内存不够用了，要先将脏页写到磁盘中

## 13.表数据删除，表文件大小不变

参数innodb_file_per_table设置为NO，Innodb数据存储在 .ibd为后缀的文件中

数据删除流程

如果需要删除一条记录，Innodb引擎只会把这条记录标记为删除，有如果符合该位置数据插入，会复用该位置，但是磁盘大小不会变，

如果我们用delete命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。

索引只要重建表,才能达到文件大小变小，alter table t engine=InnoDB

## 14.count执行

#### count(*)、count(主键id)、count(字段)和count(1)比较

count(字段)<count(主键id)<count(1)≈count(*)

基于Innodb引擎

count（主键id）：遍历整张表，把每一行的id取出，返回给server层，server拿到id，判断不可能为空，计数+1

count(1):遍历整张表，但不取值，server判断返回的行数，判断不为空+1

count（字段）:遍历整张表，把每一行这个字段取出（如果该字段非空+1，返回判断是否为空，不空+1）

count(*)：遍历，无需取值，无需判断是否为空，直接+1

综上所述 count(字段)<count(id)<count(1)≈count(*)

## 16.orderby执行过程
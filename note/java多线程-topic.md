## 1.线程run和start的区别？两次start同一个线程会怎样？

**run()**是一个普通的方法，可以重复调用，直接调用不会启动新的线程，

**start()**会启动新的线程，处于就绪状态，并没有运行，一旦获得cpu时间片，执行相应的run方法，run方法执行结束，该线程就结束了

不允许执行两次start方法，

线程首先会运行一次，然后抛出java.lang.IllegalThreadStateException异常

第二次start时，该线程可能处于死亡状态（非new新建状态）

## 2.java的线程模型？说一下volatile关键字及原理？volatile是线程安全？说一下volatile与synchronized区别？

volatile修饰变量，**能保证所有线程的可见性**，但并不能保证其原子性，当volatile修饰的变量被修改时，新值对所有线程会立即更新，

还能**避免指令的重排序**

使用场景一读N写

volatile原理：多线程之间都有各自私有的内存，volatile修改的变量对其进行写操作时，会有一个**Lock前缀的指令**，该指令会使当前处理器缓存数据写到主内存中，并其他缓存中该共享变量内存地址失效，重新从主内存中读取数据，这样就保证了多个处理器缓存时一致的。

**线程不安全的**

**区别**：

a.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的

b.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住

c.volatile只能保证变量的可见性，并不能保证原子性 而synchronized则可以保证变量的修改可见性和原子性

d.volatile不会造成的阻塞 而synchronized可能会造成线程的阻塞

e.volatile标记的变量不会被编译器优化，而synchronized可以

## 3.线程池原理？项目中实际运用？核心线程和非核心线程区别？你在项目中怎么确定核心线程数？

